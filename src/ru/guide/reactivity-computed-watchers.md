# Вычисляемые свойства и методы-наблюдатели

> В этом разделе в примерах кода используется синтаксис [однофайловых компонентов](../guide/single-file-component.md)

## Вычисляемые свойства

Иногда требуется состояние, зависящее от другого состояния — во Vue это реализуется с помощью [вычисляемых свойств](computed.md#вычисляемые-своиства) компонента. Но можно создавать вычисляемые свойства и напрямую, с помощью функции `computed`. Он принимает функцию геттера и возвращает реактивный иммутабельный [ref](reactivity-fundamentals.md#создание-автономных-ссылок-на-реактивные-значения) объект для значения, возвращаемого из геттера.

```js{2}
const count = ref(1)
const plusOne = computed(() => count.value + 1)

console.log(plusOne.value) // 2

plusOne.value++ // ошибка
```

Для создания изменяемого ref-объекта можно передать объект с функциями `get` и `set`.

```js{2-7}
const count = ref(1)
const plusOne = computed({
  get: () => count.value + 1,
  set: val => {
    count.value = val - 1
  }
})

plusOne.value = 1
console.log(count.value) // 0
```

### Отладка вычисляемых свойств <Badge text="3.2+" />

Для отладки `computed` принимает второй аргумент с опциями `onTrack` и `onTrigger`:

- `onTrack` вызывается, когда реактивное свойство или ссылка отслеживается как зависимость.
- `onTrigger` вызывается, когда коллбэк наблюдателя будет вызван изменением зависимости.

Оба коллбэка получают debugger-событие с информацией о зависимости. Рекомендуется указывать в этих коллбэках оператор `debugger` для интерактивной проверки зависимости:

```js
const plusOne = computed(() => count.value + 1, {
  onTrack(e) {
    // срабатывает, когда count.value отслеживается как зависимость
    debugger
  },
  onTrigger(e) {
    // срабатывает при изменении значения count.value
    debugger
  }
})

// доступ к plusOne вызовет срабатывание onTrack
console.log(plusOne.value)

// изменение count.value вызовет срабатывание onTrigger
count.value++
```

Обратите внимание, что `onTrack` и `onTrigger` работают только в режиме разработки.

## `watchEffect`

Чтобы применить и _автоматически применить повторно_ побочный эффект, который основан на реактивном состоянии, можно использовать функцию `watchEffect`. Он запускает функцию немедленно при отслеживании своих зависимостей и будет повторно запускать её при изменении одной из зависимостей.

```js
const count = ref(0)

watchEffect(() => console.log(count.value))
// -> выведет в консоль 0

setTimeout(() => {
  count.value++
  // -> выведет в консоль 1
}, 100)
```

### Остановка отслеживания

Если `watchEffect` вызывается во время работы функции компонента [setup()](composition-api-setup.md) или во время [хуков жизненного цикла](composition-api-lifecycle-hooks.md), то он привязывается к жизненному циклу компонента и будет автоматически останавливаться при размонтировании компонента.

Для явной остановки отслеживания можно вызвать метод, который он возвращает:

```js
const stop = watchEffect(() => {
  /* ... */
})

// позднее
stop()
```

### Аннулирование побочных эффектов

Иногда в функции наблюдателя могут быть асинхронные побочные эффекты, которые требуют дополнительных действий при их аннулировании (т.е. в случаях, когда состояние изменилось до того как эффекты завершились). Для таких случаев функция эффекта принимает функцию `onInvalidate`, которая будет использоваться для аннулирования выполненного и вызываться:

- когда эффект будет вскоре запущен повторно
- когда наблюдатель остановлен (т.е. когда компонент размонтирован, если `watchEffect` используется внутри `setup()` или хука жизненного цикла)

```js
watchEffect(onInvalidate => {
  const token = performAsyncOperation(id.value)

  onInvalidate(() => {
    // id был изменён или наблюдатель остановлен.
    // аннулирование выполняемой асинхронной операции
    token.cancel()
  })
})
```

Коллбэк для аннулирования регистрируется передачей функции внутрь, а не возвращением её из коллбэка, потому что для обработки асинхронных ошибок важно возвращаемое значение. Очень часто функция эффекта будет асинхронной при операциях загрузки данных:

```js
const data = ref(null)

watchEffect(async onInvalidate => {
  onInvalidate(() => {
    /* ... */
  }) // регистрируем функцию перед разрешением Promise
  data.value = await fetchData(props.id)
})
```

Асинхронная функция неявно возвращает Promise, но зарегистрировать функцию для очистки нужно перед разрешением Promise. Кроме того, Vue полагается на возвращаемый Promise для автоматической обработки потенциальных ошибок в цепочке Promise.

### Синхронизация времени очистки эффектов

Система реактивности Vue буферизирует аннулированные эффекты и выполняет их очистку асинхронно. Это сделано для избежания повторяющихся вызовов, когда в одном «тике» происходит много изменений состояния. Внутренняя функция компонента `update` также является эффектом. При добавлении пользовательского эффекта в очередь, по умолчанию он будет вызываться **перед** всеми эффектами `update` компонента:

```vue
<template>
  <div>{{ count }}</div>
</template>

<script>
export default {
  setup() {
    const count = ref(0)

    watchEffect(() => {
      console.log(count.value)
    })

    return {
      count
    }
  }
}
</script>
```

В этом примере:

- Значение счётчика будет выведено в консоль синхронно при первом запуске.
- При изменениях `count`, коллбэк будет вызываться **перед** обновлением компонента.

В случаях, когда эффект наблюдателя требуется повторно запускать **после** обновления компонента (например, при работе [со ссылками на элемента шаблона](composition-api-template-refs.md#отслеживание-ссылок-на-элементы-шаблона)), можно передать дополнительный объект настроек с опцией `flush` (значение по умолчанию — `'pre'`):

```js
// Будет вызываться после обновления компонента,
// поэтому можно получить доступ к обновлённому DOM
// Примечание: это также отложит первоначальный запуск эффекта
// до тех пор, пока первая отрисовка компонента не будет завершена.
watchEffect(
  () => {
    /* ... */
  },
  {
    flush: 'post'
  }
)
```

Опция `flush` также может принимать значение `'sync'`, которое принудительно заставит эффект всегда срабатывать синхронно. Однако такое поведение неэффективно и должно использоваться в крайних случаях.

С версии Vue >= 3.2.0, можно использовать псевдонимы `watchPostEffect` и `watchSyncEffect`, чтобы сделать код более понятным.

### Отладка наблюдателей

Можно использовать опции `onTrack` и `onTrigger` для отладки поведения наблюдателя.

- `onTrack` вызывается, когда реактивное свойство или ссылка начинает отслеживаться как зависимость.
- `onTrigger` вызывается, когда коллбэк наблюдателя вызван изменением зависимости.

Оба коллбэка получают событие отладчика с информацией о зависимости, о которой идёт речь. Рекомендуем указывать `debugger` в них для удобного инспектирования зависимости:

```js
watchEffect(
  () => {
    /* побочный эффект */
  },
  {
    onTrigger(e) {
      debugger
    }
  }
)
```

Обратите внимание, опции `onTrack` и `onTrigger` работают только в режиме разработки.

## `watch`

API `watch` является полным эквивалентом свойства [watch](computed.md#методы-наблюдатели) компонента. `watch` требуется конкретный источник данных для наблюдения и выполняет побочные эффекты в отдельной функции коллбэка. Он также ленив по умолчанию — т.е. коллбэк вызывается только тогда, когда наблюдаемый источник изменился.

- По сравнению с [watchEffect](#watcheffect), `watch` позволяет:

  - Лениво выполнять побочные эффекты;
  - Точнее определять какое состояние должно вызвать перезапуск;
  - Получать доступ к предыдущему и текущему значению наблюдаемого состояния.

### Отслеживание одного источника данных

В качестве источника данных для наблюдателя можно указать функцию-геттер, которая вернёт значение, или непосредственно реактивную ссылку `ref`:

```js
// наблюдение за геттер-функцией
const state = reactive({ count: 0 })
watch(
  () => state.count,
  (count, prevCount) => {
    /* ... */
  }
)

// наблюдение за ref-ссылкой
const count = ref(0)
watch(count, (count, prevCount) => {
  /* ... */
})
```

### Отслеживание нескольких источников данных

Можно отслеживать также и несколько источников одновременно, используя синтаксис наблюдателя с массивом:

```js
const firstName = ref('')
const lastName = ref('')

watch([firstName, lastName], (newValues, prevValues) => {
  console.log(newValues, prevValues)
})

firstName.value = 'John' // выведет в консоль: ["John", ""] ["", ""]
lastName.value = 'Smith' // выведет в консоль: ["John", "Smith"] ["John", ""]
```

Однако, при одновременном изменении обоих наблюдаемых источников в одной и той же функции, наблюдатель будет вызван только один раз:

```js{9-13}
setup() {
  const firstName = ref('')
  const lastName = ref('')

  watch([firstName, lastName], (newValues, prevValues) => {
    console.log(newValues, prevValues)
  })

  const changeValues = () => {
    firstName.value = 'John'
    lastName.value = 'Smith'
    // выведет в консоль: ["John", "Smith"] ["", ""]
  }

  return { changeValues }
}
```

Обратите внимание, что при нескольких синхронных изменениях наблюдатель срабатывает только один раз.

Можно форсировать срабатывание наблюдателя после каждого изменения, используя опцию `flush: 'sync'`, хотя её применение не рекомендуется. В качестве альтернативы можно воспользоваться [nextTick](../api/global-api.md#nexttick), чтобы дожидаться срабатывания наблюдателя перед внесением следующих изменений. Например:

```js{1,3}
const changeValues = async () => {
  firstName.value = 'John' // выведет в консоль: ["John", ""] ["", ""]
  await nextTick()
  lastName.value = 'Smith' // выведет в консоль: ["John", "Smith"] ["John", ""]
}
```

### Отслеживание реактивных объектов

Для сравнения значений массива или объекта, которые являются реактивными, наблюдателю потребуются, чтобы у него была копия, состоящая только из значений.

```js
const numbers = reactive([1, 2, 3, 4])

watch(
  () => [...numbers],
  (numbers, prevNumbers) => {
    console.log(numbers, prevNumbers)
  }
)

numbers.push(5) // Выведет в консоль: [1,2,3,4,5] [1,2,3,4]
```

При необходимости отслеживать изменения свойств в глубоко вложенном объекте или массиве нужно установить опцию `deep` в значение `true`:

```js
const state = reactive({
  id: 1,
  attributes: {
    name: '',
  }
})

watch(
  () => state,
  (state, prevState) => {
    console.log('без опции deep ', state.attributes.name, prevState.attributes.name)
  }
)

watch(
  () => state,
  (state, prevState) => {
    console.log('с опцией deep ', state.attributes.name, prevState.attributes.name)
  },
  { deep: true }
)

state.attributes.name = 'Alex' // выведет в консоль: "с опцией deep " "Alex" "Alex"
```

Однако, при отслеживании реактивного объекта или массива будет всегда возвращаться одна ссылка на текущее значение этого объекта как для текущего, так и для предыдущего состояния. Для полноценного отслеживания глубоко вложенных объектов или массивов, может потребоваться создавать глубокую копию значений. Это можно сделать например с помощью утилиты [lodash.cloneDeep](https://lodash.com/docs/4.17.15#cloneDeep)

```js
import _ from 'lodash'

const state = reactive({
  id: 1,
  attributes: {
    name: '',
  }
})

watch(
  () => _.cloneDeep(state),
  (state, prevState) => {
    console.log(state.attributes.name, prevState.attributes.name)
  }
)

state.attributes.name = 'Alex' // Выведет в консоль: "Alex" ""
```

### Общее поведение с `watchEffect`

Общее поведение `watch` и [`watchEffect`](#watcheffect) — в возможностях [остановки отслеживания](#остановка-отслеживания), [аннулировании побочных эффектов](#аннулирование-побочных-эффектов) (с передачей коллбэка `onInvalidate` третьим аргументом), [синхронизации времени очистки эффектов](#синхронизация-времени-очистки-эффектов) и инструментов [отладки](#отладка-наблюдателеи).
